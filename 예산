## 문제 설명  
S사에서는 부서별로 필요한 물품을 구매하기 위해 **각 부서의 요청 금액**을 조사했습니다.  
하지만, **전체 예산이 정해져 있어** 모든 부서의 요청을 들어줄 수는 없습니다.  
따라서, **최대한 많은 부서**에 물품을 지원할 수 있도록 해야 합니다.  

- 각 부서가 신청한 금액만큼 **정확히 지원**해야 하며, 일부 금액만 지원할 수는 없습니다.  
- 부서별 요청 금액이 담긴 배열 `d`와 **전체 예산** `budget`이 매개변수로 주어질 때,  
최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 `solution` 함수를 완성해주세요.

---

## 제한사항  
- `d`는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 **1 이상 100 이하**입니다.  
- `d`의 각 원소는 부서별로 신청한 금액을 나타내며, **1 이상 100,000 이하의 자연수**입니다.  
- `budget`은 예산을 나타내며, **1 이상 10,000,000 이하의 자연수**입니다.

---

## 코드  
```java
import java.util.*;

class Solution {
    public int solution(int[] d, int budget) {
        int answer = 0;
        Arrays.sort(d);  // 요청 금액을 오름차순으로 정렬하여, 적은 금액부터 지원할 수 있게 한다.
        for (int i : d) {  // 각 부서별 요청 금액에 대해 확인
            if (budget >= i) {  // 예산이 부서의 요청 금액보다 크거나 같다면
                budget -= i;  // 해당 금액을 예산에서 차감
                answer++;  // 지원 가능한 부서 수 증가
            } else {  
                break;  // 예산이 부족하면 더 이상 지원할 수 없으므로 종료
            }
        }
        return answer;  // 지원할 수 있는 부서 수 반환
    }
}
코드 설명
이 코드는 부서별 신청 금액과 전체 예산을 바탕으로, 예산 내에서 최대로 많은 부서에 물품을 지원하는 solution 함수입니다.
Arrays.sort(d);
배열 d를 오름차순으로 정렬합니다. 이렇게 하면 적은 금액부터 지원할 수 있습니다. 예산이 부족한 상황에서 더 많은 부서를 지원할 수 있도록 돕습니다.
for (int i : d)
d 배열을 순회하면서 각 부서의 요청 금액을 확인합니다.
if (budget >= i)
현재 예산이 부서의 요청 금액보다 크거나 같으면, 해당 금액을 지원합니다.
budget -= i;
예산에서 현재 부서의 요청 금액을 차감합니다.
answer++;
지원할 수 있는 부서 수를 하나씩 증가시킵니다.
else { break; }
예산이 부족하면 더 이상 지원할 수 없으므로 반복문을 종료합니다.
return answer;
지원한 부서 수를 반환합니다.
